import puredata as pd

import itertools
import pickle
import random

import numpy as np
import pandas

np.random.seed(42)

from hmmlearn import hmm
from scipy.spatial import distance

pd.post("Aethra library from py4pd")
pd.post("by Nadia Carvalho (2025)")

# --- MAIN Library ---

class pyaethra(pd.NewObject):
    name: str = "py.aethra"

    def __init__(self, args):
        self.inlets = 1
        self.outlets = 0

    def in_1_reload(self, args):
        self.reload()


# --- Utilities ---

def calculate_angular_distance(v1, v2):
    """Calculates angular distance between two vectors."""
    v1, v2 = np.array(v1), np.array(v2)
    norm1, norm2 = np.linalg.norm(v1), np.linalg.norm(v2)
    if norm1 == 0 or norm2 == 0:
        return np.pi / 2
    cos_theta = np.clip(np.dot(v1, v2) / (norm1 * norm2), -1.0, 1.0)
    return np.arccos(cos_theta)

# --- Core py4pd Objects ---

class LatentLoader(pd.NewObject):
    """py4pd object to load and manage the latent space."""
    name = "py.load_latent"

    def __init__(self, args):
        self.inlets = 1
        self.outlets = 1

    def in_1_reload(self, args):
        try:
            self.reload()
            pass
        except Exception as e:
            self.logpost(2, f"Error: {e}")

    def bang(self):
        # Default behavior when receiving a bang
        self.logpost("Send a 'load [model_name]' message to load latent space.")

    def in_1_load(self, args):
        #Standard method to load a pickle model into Pd tables.

        model_name = args[0]

        self.logpost(2, f"Loading Model: {model_name}")
        path = f"{self.get_current_dir()}/{model_name}"

        try:
            source = pandas.read_pickle(path)

            if isinstance(source['latent'][0], str):
                source['latent'] = source['latent'].apply(
                    lambda x: np.fromstring(x[1:-1], dtype=float, sep=' ')
                )

            # communicates with Pd tables
            self.tabwrite("table_n", list(np.array(source.index.values, float)), resize=True)
            self.tabwrite("table_x", list(source['x'].values), resize=True)
            self.tabwrite("table_y", list(source['y'].values), resize=True)
            self.tabwrite("table_latent", list(np.ones(source.latent[0].size, float)), resize=True)

            self.out(0, pd.FLOAT, 1)

        except Exception as e:
            self.error(f"Failed to load latent space: {e}")

class NavigationMechanism(pd.NewObject):
    #py.core_choice: Decision mechanism for navigation.
    name = "py.navigation_mechanism"

    def __init__(self, args):
        self.inlets = 1
        self.outlets = 1

        self.source = None
        self.distance_matrix = None
        self.hmm_model = None

        self.mode = 0 # 0 -> HMM, 1 -> k-NN
        self.seq_len = 20
        self.latent_dimension_weights = np.ones(16, float)

    def in_1_reload(self, args):
        try:
            self.reload()
        except Exception as e:
            self.logpost(2, f"Error: {e}")

    def in_1_loadsource(self, args):
        model_name = args[0]
        self.logpost(2, f"Loading Model: {model_name}")
        path = f"{self.get_current_dir()}/{model_name}"

        try:
            df = pandas.read_pickle(path)
            # Get Source Latent
            self.source = pandas.DataFrame().from_records(df.loc[:,'latent'])
            # Set Latent Weights
            self.latent_dimension_weights = np.ones(self.source[0].size, float)
            # Generate distance matrices
            self.distance_matrix = {}
            for i in range(self.source.shape[1]):
                col_data = self.source.iloc[:, i].values
                diff = np.abs(col_data[:, None] - col_data)
                self.distance_matrix[i] = diff
        except Exception as e:
            self.logpost(2, f"Not able to load latent space, {model_name}, because {e}")

    def in_1_loadhmm(self, args):
        model_name = args[0]
        self.logpost(2, f"Loading HMM Model {model_name}")
        path = f"{self.get_current_dir()}/{model_name}"

        try:
            with open(path, 'rb') as f:
                self.hmm_model = pickle.load(f)
        except Exception as e:
            self.logpost(2, f"Not able to load HMM model, {model_name}, because {e}")

    def in_1_run(self, args: list):
        actual, closeness = args

        if closeness < 0.05:
            self.out(0, pd.FLOAT, actual+1)
            return

        # Motion-Based Navigation Strategy
        if self.mode == 0:
            motion = 'P' if closeness <= 1/3 else 'O' if closeness <= 2/3 else 'C'
            try:
                # 1. Select model based on motion type (OR, P, O, or C)
                model_hmm = self.hmm_model.get(motion)

                # 2. Decode the current hidden state sequence from the initial latent vectors
                obs = self.source.iloc[actual:actual+1].values
                _, states = model_hmm.decode(obs)

                # 3. Sample next hidden state based on transition matrix (transmat_)
                next_state = np.random.choice(model_hmm.n_components, p=model_hmm.transmat_[states[-1]])

                # 4. Sample the next latent observation from a multivariate normal distribution
                # Technical note: full covariance matrix captures inter-dimensional dependencies
                pred = model_hmm.means_[next_state] + np.random.multivariate_normal(np.zeros(16), model_hmm.covars_[next_state])

                # 5. Find nearest neighbor in original latent space
                idx = np.argmin(distance.cdist([pred], self.source, 'euclidean'))
                self.out(0, pd.FLOAT, idx)
            except Exception as e:
                self.logpost(2, f"Error on HMM: {e}")
                self.out(0, pd.FLOAT, actual + 1)

        # Distance-Based Navigation Strategy
        else:
            try:
                # 1. Calculate Weighted Euclidean Distance
                # self.distance_matrix contains the pre-computed differences per dimension
                # We apply the user-defined weights to prioritize specific timbral features
                weighted_distances = np.sqrt(np.sum([
                    self.distance_matrix[dim][int(actual + 1)] * w
                    for dim, w in enumerate(self.latent_dimension_weights)
                ], axis=0))

                # 2. Sort and Segment the Manifold into 25 Bins
                ids = np.argsort(weighted_distances)
                bin_size = len(ids) // 25

                # 3. Map the One-Knob Control 'C' (closeness) to a Bin Index
                # We use a clipping function to ensure the index stays within [0, 24]
                bin_idx = int(np.clip(closeness * (num_bins - 1), 0, num_bins - 1))

                # 4. Weighted Random Choice within the Focus Window
                # We extract the IDs for the selected bin and calculate probabilities
                # inversely proportional to distance (closer units are more likely)
                selected_ids = ids[bin_idx * bin_size : (bin_idx + 1) * bin_size]
                bin_distances = weighted_distances[selected_ids]

                # Inverse weighting: subtract distance from max to prioritize nearest neighbors
                max_bin_d = np.max(bin_distances)
                p_weights = (max_bin_d - bin_distances) + 1e-6 # small epsilon to avoid zero weights

                choice = random.choices(selected_ids, weights=p_weights, k=1)[0]
                self.out(0, pd.FLOAT, choice)
            except Exception:
                self.logpost(2, f"Error on k-NN: {e}")
                self.out(0, pd.FLOAT, actual + 1)

    def in_1_list(self, l: list):
        self.latent_dimension_weights = np.asarray(l)

    def in_1_setmode(self, mode: float):
        self.logpost(2, f"Setting mode: {mode}")
        self.mode = mode[0]

    def in_1_setseqlen(self, seq_len: float):
        self.logpost(2, f"Setting sequence length: {seq_len}")
        self.seq_len = seq_len[0]
