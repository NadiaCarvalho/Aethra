import puredata as pd

import itertools
import pickle
import random

import numpy as np
import pandas

from hmmlearn import hmm
from scipy.spatial import distance

pd.post("Aethra library from py4pd")
pd.post("by Nadia Carvalho (2025)")

# --- MAIN Library ---

class pyaethra(pd.NewObject):
    name: str = "py.aethra"

    def __init__(self, args):
        self.inlets = 1
        self.outlets = 0

    def in_1_reload(self, args):
        self.reload()


# --- Utilities ---

def calculate_angular_distance(v1, v2):
    """Calculates angular distance between two vectors."""
    v1, v2 = np.array(v1), np.array(v2)
    norm1, norm2 = np.linalg.norm(v1), np.linalg.norm(v2)
    if norm1 == 0 or norm2 == 0:
        return np.pi / 2
    cos_theta = np.clip(np.dot(v1, v2) / (norm1 * norm2), -1.0, 1.0)
    return np.arccos(cos_theta)

# --- Core py4pd Objects ---

class LatentLoader(pd.NewObject):
    """py4pd object to load and manage the latent space."""
    name = "py.load_latent"

    def __init__(self, args):
        self.inlets = 1
        self.outlets = 1

    def in_1_reload(self, args):
        try:
            self.reload()
            pass
        except Exception as e:
            self.logpost(2, f"Error: {e}")

    def bang(self):
        # Default behavior when receiving a bang
        self.logpost("Send a 'load [model_name]' message to load latent space.")

    def in_1_load(self, args):
        #Standard method to load a pickle model into Pd tables.

        model_name = args[0]

        self.logpost(2, f"Loading Model: {model_name}")
        path = f"{self.get_current_dir()}/models/{model_name}.pkl"

        try:
            source = pandas.read_pickle(path)

            if isinstance(source['latent'][0], str):
                source['latent'] = source['latent'].apply(
                    lambda x: np.fromstring(x[1:-1], dtype=float, sep=' ')
                )

            # communicates with Pd tables
            self.tabwrite("table_n", list(np.array(source.index.values, float)), resize=True)
            self.tabwrite("table_x", list(source['x'].values), resize=True)
            self.tabwrite("table_y", list(source['y'].values), resize=True)
            self.tabwrite("table_latent", list(np.ones(source.latent[0].size, float)), resize=True)

            self.out(0, pd.FLOAT, 1)

        except Exception as e:
            self.error(f"Failed to load latent space: {e}")

class CoreChoice(pd.NewObject):
    #py.coreChoice: Decision mechanism for navigation.
    name = "py.coreChoice"

    def __init__(self, args):
        self.inlets = 1
        self.outlets = 1

        self.source = None
        self.distance_matrix = None
        self.hmm_model = None

        self.mode = 0 # 0 -> HMM, 1 -> k-NN
        self.seq_len = 20
        self.latent_dimension_weights = np.ones(16, float)

    def in_1_reload(self, args):
        try:
            self.reload()
        except Exception as e:
            self.logpost(2, f"Error: {e}")

    def in_1_loadsource(self, args):
        model_name = args[0]
        self.logpost(2, f"Loading Model: {model_name}")
        path = f"{self.get_current_dir()}/models/{model_name}.pkl"

        try:
            df = pandas.read_pickle(path)
            # Get Source Latent
            self.source = pandas.DataFrame().from_records(df.loc[:,'latent'])
            # Set Latent Weights
            self.latent_dimension_weights = np.ones(self.source[0].size, float)
            # Generate distance matrices
            self.distance_matrix = {}
            for i in range(self.source.shape[1]):
                col_data = self.source.iloc[:, i].values
                diff = np.abs(col_data[:, None] - col_data)
                self.distance_matrix[i] = diff
        except Exception as e:
            self.logpost(2, f"Not able to load latent space, {model_name}, because {e}")

    def in_1_loadhmm(self, args):
        model_name = args[0]
        self.logpost(2, f"Loading HMM Model {model_name}")
        path = f"{self.get_current_dir()}/models/{model_name}.pkl"

        try:
            with open(path, 'rb') as f:
                self.hmm_model = pickle.load(f)
        except Exception as e:
            self.logpost(2, f"Not able to load HMM model, {model_name}, because {e}")

    def in_1_run(self, args: list):
        actual, closeness = args

        if closeness < 0.05:
            self.out(0, pd.FLOAT, actual+1)
            return

        # HMM Prediction Mode
        if self.mode == 0:
            motion = 'P' if closeness <= 0.4 else 'O' if closeness <= 0.75 else 'C'
            try:
                # Prediction logic using HMM
                model_hmm = self.hmm_model.get(motion)
                obs = self.source.iloc[actual:actual+1].values
                _, states = model_hmm.decode(obs)

                next_state = np.random.choice(model_hmm.n_components, p=model_hmm.transmat_[states[-1]])
                pred = model_hmm.means_[next_state]

                # Find nearest neighbor in original latent space
                idx = np.argmin(distance.cdist([pred], self.source, 'euclidean'))
                self.out(0, pd.FLOAT, idx)
            except Exception as e:
                self.logpost(2, f"Error on HMM: {e}")
                self.out(0, pd.FLOAT, actual + 1)

        # k-NN Distance Strategy Mode
        else:
            try:
                weighted_distances = np.zeros(len(self.source))
                for i, w in enumerate(self.latent_dimension_weights):
                    weighted_distances += self.distance_matrix[i][int(actual + 1)] * w

                ids = np.argsort(weighted_distances)
                bin_size = len(ids) // 25
                bin_idx = int(closeness * 20)  # Simplified bin mapping

                # Weighted random choice within the selected bin
                selected_ids = ids[bin_idx * bin_size : (bin_idx + 1) * bin_size]
                max_d = np.max(weighted_distances)
                p_weights = [max_d - weighted_distances[i] for i in selected_ids]

                choice = random.choices(selected_ids, weights=p_weights, k=1)[0]
                self.out(0, pd.FLOAT, choice)
            except Exception:
                self.logpost(2, f"Error on k-NN: {e}")
                self.out(0, pd.FLOAT, actual + 1)

    def in_1_list(self, l: list):
        self.latent_dimension_weights = np.asarray(l)

    def in_1_setmode(self, mode: float):
        self.logpost(2, f"Setting mode: {mode}")
        self.mode = mode[0]

    def in_1_setseqlen(self, seq_len: float):
        self.logpost(2, f"Setting sequence length: {seq_len}")
        self.seq_len = seq_len[0]
